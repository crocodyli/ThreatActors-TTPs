#!/usr/bin/env node

/**
 * scripts/build-cve-index.js
 * 
 * Scans all threat actor folders in the ThreatActors-TTPs repo,
 * finds CVEs.json files, and consolidates them into a single
 * cve-index.json file at the root.
 * 
 * Run: node scripts/build-cve-index.js
 */

const fs = require('fs');
const path = require('path');

// Root directory of the repo (parent of scripts/)
const REPO_ROOT = path.join(__dirname, '..');

// Output file
const OUTPUT_FILE = path.join(REPO_ROOT, 'cve-index.json');

console.log(`[CVE] Repository root: ${REPO_ROOT}`);

/**
 * Get all directories in the root (these are threat actor folders)
 */
function getThreatActorFolders() {
  let entries;
  
  try {
    entries = fs.readdirSync(REPO_ROOT, { withFileTypes: true });
  } catch (error) {
    console.error(`[CVE] ‚ùå Failed to read directory ${REPO_ROOT}:`, error.message);
    return [];
  }
  
  const folders = entries
    .filter(entry => entry.isDirectory())
    .filter(entry => !entry.name.startsWith('.')) // Skip hidden folders
    .filter(entry => !['node_modules', 'scripts', 'data'].includes(entry.name)) // Skip system folders
    .map(entry => entry.name);
  
  console.log(`[CVE] üìÅ Directories found: ${folders.length} folders`);
  
  return folders;
}

/**
 * Read CVEs.json from a threat actor folder if it exists
 */
function readCVEsFile(folderName) {
  const cveFilePath = path.join(REPO_ROOT, folderName, 'CVEs.json');
  
  if (!fs.existsSync(cveFilePath)) {
    return null;
  }
  
  try {
    const content = fs.readFileSync(cveFilePath, 'utf-8');
    const data = JSON.parse(content);
    return data;
  } catch (error) {
    console.error(`[CVE] ‚ùå Failed to parse ${folderName}/CVEs.json:`, error.message);
    return null;
  }
}

/**
 * Main function
 */
function buildCVEIndex() {
  console.log('[CVE] üîç Scanning threat actor folders...');
  
  const folders = getThreatActorFolders();
  
  if (folders.length === 0) {
    console.error('[CVE] ‚ùå No folders found in repository root');
    // Create empty index so git doesn't fail
    fs.writeFileSync(OUTPUT_FILE, JSON.stringify({}, null, 2), 'utf-8');
    return;
  }
  
  console.log(`[CVE] üìÅ Scanning ${folders.length} folders for CVEs.json files...`);
  
  const cveIndex = {};
  let totalCVEs = 0;
  let foldersWithCVEs = 0;
  
  for (const folder of folders) {
    const cveData = readCVEsFile(folder);
    
    if (cveData && cveData.cves && Array.isArray(cveData.cves)) {
      const groupName = cveData.group || folder;
      cveIndex[groupName] = {
        cves: cveData.cves
      };
      
      totalCVEs += cveData.cves.length;
      foldersWithCVEs++;
      console.log(`[CVE]   ‚úì ${groupName}: ${cveData.cves.length} CVEs`);
    }
  }
  
  if (foldersWithCVEs === 0) {
    console.log('[CVE] ‚ö†Ô∏è  No CVEs.json files found in any folders');
    // Still create an empty index file
    fs.writeFileSync(OUTPUT_FILE, JSON.stringify({}, null, 2), 'utf-8');
    console.log('[CVE] üìÑ Created empty cve-index.json');
    return;
  }
  
  // Write the consolidated index
  console.log('[CVE] üìù Writing cve-index.json...');
  fs.writeFileSync(
    OUTPUT_FILE,
    JSON.stringify(cveIndex, null, 2),
    'utf-8'
  );
  
  console.log('[CVE] ‚úÖ CVE Index built successfully!');
  console.log(`[CVE]    üìä ${foldersWithCVEs} groups with CVEs`);
  console.log(`[CVE]    üî¢ ${totalCVEs} total CVEs`);
  console.log(`[CVE]    üìÑ Output: ${OUTPUT_FILE}`);
}

// Run the script
try {
  buildCVEIndex();
  console.log('[CVE] Done!');
  process.exit(0);
} catch (error) {
  console.error('[CVE] ‚ùå Error building CVE index:', error);
  console.error(error.stack);
  process.exit(1);
}
