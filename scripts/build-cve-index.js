#!/usr/bin/env node

/**
 * Build CVE Index
 * 
 * Scans all threat actor folders in the ThreatActors-TTPs repo,
 * finds CVEs.json files, and consolidates them into a single
 * cve-index.json file at the root.
 * 
 * Run: node .github/scripts/build-cve-index.js
 */

const fs = require('fs');
const path = require('path');

// Root directory of the repo (go up two levels from .github/scripts/)
const REPO_ROOT = path.resolve(__dirname, '../..');

// Output file
const OUTPUT_FILE = path.join(REPO_ROOT, 'cve-index.json');

console.log(`ğŸ“‚ Repository root: ${REPO_ROOT}`);

/**
 * Get all directories in the root (these are threat actor folders)
 */
function getThreatActorFolders() {
  let entries;
  
  try {
    entries = fs.readdirSync(REPO_ROOT, { withFileTypes: true });
  } catch (error) {
    console.error(`âŒ Failed to read directory ${REPO_ROOT}:`, error.message);
    return [];
  }
  
  const folders = entries
    .filter(entry => entry.isDirectory())
    .filter(entry => !entry.name.startsWith('.')) // Skip hidden folders
    .filter(entry => entry.name !== 'node_modules') // Skip node_modules
    .map(entry => entry.name);
  
  console.log(`ğŸ“ Directories found: ${folders.join(', ')}`);
  
  return folders;
}

/**
 * Read CVEs.json from a threat actor folder if it exists
 */
function readCVEsFile(folderName) {
  const cveFilePath = path.join(REPO_ROOT, folderName, 'CVEs.json');
  
  if (!fs.existsSync(cveFilePath)) {
    return null;
  }
  
  try {
    const content = fs.readFileSync(cveFilePath, 'utf-8');
    const data = JSON.parse(content);
    return data;
  } catch (error) {
    console.error(`âŒ Failed to parse ${folderName}/CVEs.json:`, error.message);
    return null;
  }
}

/**
 * Main function
 */
function buildCVEIndex() {
  console.log('ğŸ” Scanning threat actor folders...');
  
  const folders = getThreatActorFolders();
  
  if (folders.length === 0) {
    console.error('âŒ No folders found in repository root');
    process.exit(1);
  }
  
  console.log(`ğŸ“ Found ${folders.length} folders to scan`);
  
  const cveIndex = {};
  let totalCVEs = 0;
  let foldersWithCVEs = 0;
  
  for (const folder of folders) {
    const cveData = readCVEsFile(folder);
    
    if (cveData && cveData.cves && Array.isArray(cveData.cves)) {
      const groupName = cveData.group || folder;
      cveIndex[groupName] = {
        cves: cveData.cves
      };
      
      totalCVEs += cveData.cves.length;
      foldersWithCVEs++;
      console.log(`  âœ“ ${groupName}: ${cveData.cves.length} CVEs`);
    }
  }
  
  if (foldersWithCVEs === 0) {
    console.log('âš ï¸  No CVEs.json files found in any folders');
    // Still create an empty index file
    fs.writeFileSync(OUTPUT_FILE, JSON.stringify({}, null, 2), 'utf-8');
    console.log('ğŸ“„ Created empty cve-index.json');
    return;
  }
  
  // Write the consolidated index
  console.log('\nğŸ“ Writing cve-index.json...');
  fs.writeFileSync(
    OUTPUT_FILE,
    JSON.stringify(cveIndex, null, 2),
    'utf-8'
  );
  
  console.log('\nâœ… CVE Index built successfully!');
  console.log(`   ğŸ“Š ${foldersWithCVEs} groups with CVEs`);
  console.log(`   ğŸ”¢ ${totalCVEs} total CVEs`);
  console.log(`   ğŸ“„ Output: ${OUTPUT_FILE}`);
}

// Run the script
try {
  buildCVEIndex();
  process.exit(0);
} catch (error) {
  console.error('\nâŒ Error building CVE index:', error);
  console.error(error.stack);
  process.exit(1);
}
